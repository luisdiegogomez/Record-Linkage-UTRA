import numpy as np

import pandas as pd

import math as mt

'''This implementation of record linkage is implemented from Bayesian Estimation of Bipartite Matchings
for Record Linkage by Sandile (2016)'''

## Initilizating Datasets From CSV Files and Global Variables:

# Make sure file paths are based on wherever your files are locally:
X_1 = pd.read_csv("~/OneDrive/Documents/R/Record-Linkage-UTRA/TestCSV.csv",dtype=str) # Equivalent to A in DeVone Paper, 
                                                                                      # individual record indexed by i
X_2 = pd.read_csv("~/OneDrive/Documents/R/Record-Linkage-UTRA/TestCSV.csv",dtype=str) # Equivalent to B in DeVone Paper, 
                                                                                      # individual record indexed by j

## Global Variables:

n_1 = len(X_1.index) # Equivalent to N_a
n_2 = len(X_2.index) # Equivalent to N_b
  
# Prior modifications to column headings in csv datasets most likely needed to 
# ensure code identifies the correct intersecting variables:
X_1f = X_1[np.sort(X_1.columns.intersection(X_2.columns))]
X_2f = X_2[np.sort(X_2.columns.intersection(X_1.columns))]
  
F = len(X_1f.columns) # Equivalent to k, 
                      # number of comparison criteria (intersecting varibles for each record) 

## Filling in Comparison Vectors (Gamma Vectors):

#Jaro-Winkler Distance for String Comparison
def jaro_winkler_distance(s1, s2):
    # Jaro distance
    len_s1, len_s2 = len(s1), len(s2)
    max_dist = max(len_s1, len_s2) // 2 - 1
    matches = 0
    transpositions = 0

    # Find matching characters
    for i in range(len_s1):
        start = max(0, i - max_dist)
        end = min(i + max_dist + 1, len_s2)
        for j in range(start, end):
            if s1[i] == s2[j]:
                matches += 1
                if i != j:
                    transpositions += 1
                break

    if matches == 0:
        return 0.0

    jaro = (
        (matches / len_s1)
        + (matches / len_s2)
        + ((matches - transpositions / 2) / matches)
    ) / 3

    # Winkler modification
    prefix_len = 0
    for i in range(min(len_s1, len_s2)):
        if s1[i] == s2[i]:
            prefix_len += 1
        else:
            break

    jaro_winkler = jaro + (0.1 * prefix_len * (1 - jaro))

    jaro_winkler = round((-jaro_winkler + 1), 2)

    if jaro_winkler < 0:
        jaro_winkler = 0
    
    return jaro_winkler

# Function that outputs tuple with 3-D array (dimensions n_1, n_2, F) representing the comparison gamma 
# vectors for each pair of records between all files in X_1 and X_2 as first element of outputted tuple, Pandas Dataframe 
# of same gamma vectors in second element of tuple, (meant for visual representation of overall gamma vector for each 
# pair of records):
def fill_comparison_arrays_matrix() -> tuple:
    # Initializing matrix of comparison gamma vectors:
    comparison_arrays = np.full((n_1,n_2,F), fill_value = 0, dtype=float) # n_1 by n_2 matrix with each cell containing 
                                                                          # a gamma comparison vector (of size F) for each  
                                                                          # pair of files (indexed i,j) in X_1 and X_2

    # Filling comparison vectors:
    for i in range(n_1):
        for j in range(n_2):
            for f in range(F):
                comparison_arrays[i,j,f] = jaro_winkler_distance(X_1f.iat[i,f],X_2f.iat[j,f])

    # Converting the matrix of comparison vectors to a pandas DataFrame
    dataframe_comp_arrays = pd.DataFrame(index=range(n_1), columns=range(n_2))
    for i in range(n_1):
        for j in range(n_2):
            dataframe_comp_arrays.iat[i, j] = comparison_arrays[i,j]

    return(comparison_arrays, dataframe_comp_arrays)

# Function that outputs 2-D array (dimensions F, n_1*n_2) representing the values 
# of each comparison varaible for each pair (meant for easier computations in Gibbs sampling):
def fill_comparison_arrays_f_rows() -> np.ndarray:
    # Initializing matrix of comparison gamma vectors:
    comparison_values = np.full((F, (n_1*n_2)), fill_value = 0, dtype=float) # F by n_1*n_2 matrix representing the comparison 
                                                                             # value f at pair of records ij 
                                                                             # (indexed by [n_1*i + j] when indexing starts at 0) 

    # Filling comparison values:
    for i in range(n_1):
        for j in range(n_2):
            for f in range(F):
                comparison_values[f, (n_1*i + j)] = jaro_winkler_distance(X_1f.iat[i,f],X_2f.iat[j,f])

    ## Converting the matrix of comparison vectors to a pandas DataFrame
    # comparison_values = pd.DataFrame(comparison_values)

    return(comparison_values)

gamma_vector_matrices = fill_comparison_arrays_matrix()
gamma_matrix = gamma_vector_matrices[0]
gamma_dataframe = gamma_vector_matrices[1]
comparison_array = fill_comparison_arrays_f_rows()
print("Gamma Vectors Matrix:")
print(gamma_matrix)
print("Gamma Vectors DataFrame")
print(gamma_dataframe)
print("Comparison Array:")
print(comparison_array)

## Sampling Theta Values for Comparison Vectors:
def theta_and_c_sampler(comparison_arrays:np.ndarray, t:int):
    #Establishing initial parameters for the Dirchlet Distributions from which we're sampling:
    theta_M_params = [1,2]
    theta_U_params = [1,1]
    pi_params = [1,1]

    pi = np.random.beta(pi_params[0],pi_params[1])

    # Initilaizaing Z with each record pair having a random match:
    Z = np.full((1,n_2), 0, dtype=int) # Equivalent to C
    for j in range(n_2):
        Z = np.random.binomial(1,pi)
    X_1_shuffled = np.random.shuffle(np.array(range(n_1)))
    for j in range(n_2):
        if Z[j] == 1: 
            Z[j] = X_1_shuffled[i] + j 
        else: 
            Z[j] = j 


    ## Gibbs Sampler for Theta Values:
    theta_values = np.full((K, t, 2), 0) # Array with K rows (one for each comparison variable),
                                         # t columns (one for each number of iterations), and 
                                         # two theta values in each cell (Theta_M and Theta_U 
                                         # values for each comparison variable)

    for i in range(t):
        for gamma_col in range(K):
            ## Sampling for Theta_M Values:
            # First Parameter for Dirichlet Distribution:
            alpha_M_0 = theta_M_params[0] + np.sum(comparison_arrays[:,:,gamma_col]*C)
            # Second Parameter for Dirichlet Distribution:
            alpha_M_1 = theta_M_params[1] + np.sum((1- comparison_arrays[:,:,gamma_col])*C)

            theta_values[gamma_col,i,0] = np.random.dirichlet(np.array(alpha_M_0, alpha_M_1))
            ## Sampling for Theta_U Values:
            # First Parameter for Dirichlet Distribution:
            alpha_U_0 = theta_U_params[0] + np.sum(comparison_arrays[:,:,gamma_col]*(1-C))
            # Second Parameter for Dirichlet Distribution:
            alpha_U_1 = theta_U_params[1] + np.sum((1- comparison_arrays[:,:,gamma_col])*(1-C))

            theta_values[gamma_col,i,1] = np.random.dirichlet(np.array(alpha_U_0, alpha_U_1))

        C_tplus1 = np.full((N_a,N_b), 0)

        # Outputs prob of gamma vector given theta values of just theta_m or theta_u:
        def gamma_vec_prob(gamma_vec:np.ndarray,theta_values:np.ndarray):
            output_prob = 1
            for k in range(K):
                    output_prob = output_prob*(theta_values[k]**gamma_vec[k])*(1-theta_values[k])**(1-gamma_vec[k])

        for a in range(N_a):
            for b in range(N_b):
                numerator = gamma_vec_prob(comparison_arrays[a,b],theta_values[:,i,0])/gamma_vec_prob(comparison_arrays[a,b],theta_values[:,i,1])
                denomintor = 0
                for j in range(N_b):
                    denomintor += ((gamma_vec_prob(comparison_arrays[a,j],theta_values[:,i,0])/gamma_vec_prob(comparison_arrays[a,j],theta_values[:,i,1])) + P(THETA))(C[a,j] == 0)
                if denomintor == 0:
                    C_tplus1[a,b] = 0
                else:
                    C_tplus1[a,b] = np.random.binomial(1,(numerator/denomintor))


    return(theta_values)